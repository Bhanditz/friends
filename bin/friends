#!/usr/bin/env ruby

require "gli"
require "minitest/pride"

require "friends/introvert"
require "friends/version"

include GLI::App

program_desc "Spend time with the people you care about. Introvert-tested. "\
  "Extrovert-approved."

version Friends::VERSION

subcommand_option_handling :normal
arguments :strict

switch [:quiet],
  negatable: false,
  desc: "Quiet output messages"

flag [:filename],
  arg_name: "FILENAME",
  default_value: "./friends.md",
  desc: "Set the location of the friends file"

switch [:clean],
  negatable: false,
  desc: "Force a clean write of the friends file"

desc "Lists friends or activities"
command :list do |list|
  list.desc "List all friends"
  list.command :friends do |list_friends|
    list_friends.action do
      puts @introvert.list_friends
    end
  end

  list.desc "List favorite friends"
  list.command :favorites do |list_favorites|
    list_favorites.flag [:limit],
      arg_name: "NUMBER",
      default_value: 10,
      desc: "The number of friends to return"

    list_favorites.action do |_, options|
      limit = options[:limit].to_i
      favorites = @introvert.list_favorites(limit: limit)

      if limit == 1
        puts "Your best friend is #{favorites.first}"
      else
        puts "Your favorite friends:"

        num_str_size = favorites.size.to_s.size + 1
        favorites.each.with_index(1) do |name, rank|
          puts "#{"#{rank}.".ljust(num_str_size)} #{name}"
        end
      end
    end
  end

  list.desc "Lists all activities"
  list.command :activities do |list_activities|
    list_activities.flag [:limit],
      arg_name: "NUMBER",
      default_value: 10,
      desc: "The number of activities to return"

    list_activities.flag [:with],
      arg_name: "NAME",
      desc: "List only activities involving the given friend"

    list_activities.action do |_, options|
      limit = options[:limit].to_i
      puts @introvert.list_activities(limit: limit, with: options[:with])
    end
  end
end

desc "Adds a friend or activity"
command :add do |add|
  add.desc "Adds a friend"
  add.arg_name "NAME"
  add.command :friend do |add_friend|
    add_friend.action do |_, _, args|
      friend = @introvert.add_friend(name: args.first)
      @message = "Friend added: \"#{friend.name}\""
    end
  end

  add.desc "Adds an activity"
  add.arg_name "DESCRIPTION"
  add.command :activity do |add_activity|
    add_activity.action do |_, _, args|
      activity = @introvert.add_activity(serialization: args.first)
      @message = "Activity added: \"#{activity.display_text}\""
    end
  end
end

desc "Graph"
arg_name "NAME"
command :graph do |graph|
  graph.action do |_, _, args|
    data = @introvert.graph(name: args.first)

    data.each do |month, count|
      print "#{month} |"

      colorer = Minitest::PrideLOL.new($stdout)
      count.times { print colorer.pride "â–ˆ" }
      puts
    end
  end
end

desc "Suggest"
command :suggest do |suggest|
  suggest.action do
    suggestions = @introvert.suggest

    puts "Distant friend: \e[1m#{suggestions[:distant].sample}\e[0m"
    puts "Moderate friend: \e[1m#{suggestions[:moderate].sample}\e[0m"
    puts "Close friend: \e[1m#{suggestions[:close].sample}\e[0m"
  end
end

desc "Cleans your friends.md file"
command :clean do |clean|
  clean.action do
    filename = @introvert.clean
    @message = "File cleaned: \"#{filename}\""
  end
end

# Before each command, clean up all arguments and create the global Introvert.
pre do |global_options, _, options|
  final_options = global_options.merge!(options).select do |key, _|
    [:filename].include? key
  end

  @introvert = Friends::Introvert.new(final_options)
  true
end

post do |global_options|
  # After each command, clean if requested with the --clean flag.
  if global_options[:clean]
    filename = @introvert.clean
    @message = "File cleaned: \"#{filename}\""
  end

  # Print the output message (if there is one) unless --quiet is passed.
  puts @message unless @message.nil? || global_options[:quiet]
end

# If an error is raised, print the message to STDERR and exit the program.
on_error do |error|
  abort "Error: #{error}"
end

# Run the program and return the exit code corresponding to its success.
exit run(ARGV)
